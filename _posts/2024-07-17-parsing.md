---
layout: posts
title: "Parsing"
date: 2024-07-17 13:00:00 +0900
---

데이터, 특히 문자열을 다루다 보면 파싱 작업이 필요할 때가 있습니다. 정확하고 효율적인 파싱을 위해 관련한 학습을 해봅시다.

## 컴파일러의 관점

무언가를 학습할 때 좋은 방법 중 하나는 그것을 가장 잘하는 사람 혹은 도구의 관점에서 생각하는 겁니다. 파싱을 밥먹듯이 하는 컴파일러의 관점에서 생각해 봅시다.

컴파일러는 파싱 작업을 다음과 같은 과정으로 나누어 진행합니다.

1. 어휘 분석
    - 토큰화 및 분류
    
2. 구문 분석
    - 추상 구문 트리(AST) 생성

## 어휘 분석

어휘 분석은 컴파일러의 첫 번째 단계입니다. 목적은 입력을 토큰 시퀀스로 변환하는 것입니다.

### 토큰은 무엇인가 ?

언어 문법에서 하나의 단위로 처리될 수 있는 문자열 입니다.

예시는 아래와 같습니다.
```text
키워드: 'for', 'while', 'if', ...

식별자: 변수명, 함수명, ...

연산자: '+', '++', '-', ...

구분자: ',', ';', ...
```

### 토큰화

입력 텍스트를 토큰으로 나누는 과정입니다. 일반적으로 정규식을 활용해서 수행합니다.

정규식(Regular Expression)은 문자열에서 특정 패턴을 찾고, 일치시키고, 조작하기 위해 사용하는 강력한 도구입니다. 
정규식은 문자열 검색, 텍스트 일치, 텍스트 추출 및 텍스트 변환 작업에서 널리 사용됩니다.

이메일에 대한 정규식을 예시로 보자면,
```text
[a-zA-Z0-9._]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}
```
- `[a-zA-Z0-9._]+`: (식별자) 하나 이상의 알파벳, 숫자, 점, 밑줄을 허용합니다.
- `@`: '@' 문자.
- `[a-zA-Z0-9.-]+`: (도메인) 하나 이상의 알파벳, 숫자, 점, 대시를 허용합니다.
- `\.`: '.' 문자.
- `[a-zA-Z]{2,}`: (com, net 등)최소 2개의 알파벳 문자.

위와 같이 표현할 수 있습니다.

이와 같이 적절한 정규식을 만들어 토큰으로 나눠야 합니다.

### 토큰 분류

정규식으로 나눈 각 토큰의 유형을 결정해야 합니다. 앞서 봤듯이 키워드, 식별자, 연산자 등으로 분류해야 합니다.

## 구문 분석

구문 분석 또는 구문 분석은 어휘 분석 이후의 두 번째 단계입니다.

어휘 분석의 결과로 받은 토큰으로 올바른 구문인지 여부를 확인합니다.

추상 구문 트리(AST) 데이터 구조를 구축하여 이를 수행하며, 트리는 미리 정의된 언어의 문법과 입력 문자열을 사용하여 구성됩니다.

주어진 입력이 구문 트리로 생성될 수 있는 경우, 입력 문자열이 올바른 구문에 있는 것으로 확인됩니다. 그렇지 않은 경우 구문 분석기가 오류를 보고합니다.

## 예시

```c
int main() {
    return 0;
}
```
다음 코드에 대한 파싱을 수행해 봅시다.

위의 코드를 토큰화 하면 다음과 같습니다.

- 'int' (키워드)
- 'main' (식별자)
- '(' (연산자)
- ')' (연산자)
- '{' (연산자)
- 'return' (키워드)
- '0' (리터럴)
- ';' (연산자)
- '}' (연산자)

그리고 C언어의 문법으로 AST를 형성하면 다음과 같습니다.

```yaml
Program
└── FunctionDefinition
    ├── ReturnType: int
    ├── FunctionName: main
    ├── Parameters: ()
    └── Body
        └── ReturnStatement
            └── ReturnValue: 0
```
