---
layout: posts
title: "동시성"
date: 2024-07-29 10:00:00 +0900
---

2024년 7월 기준 가장 최신의 iPhone의 CPU는 6개의 코어를 가집니다.

이에 따라 6개의 코어를 최대한 잘 활용할 수 있는 코드 짤 것이 프로그래머에게 과제로 주어졌습니다.

# 동시성과 병렬성

병렬성(parallelism)은 연관된 연산을 다수의 코어를 활용해 동시에 수행하는 것을 말합니다.

동시성 혹은 병행성(concurrency)은 독립적 작업의 수행을 조율(composition)하는 것입니다.

구분되는 것은 병렬성을 위해서는 다수의 코어를 사용한다는 것이고, 동시성은 하나의 코어로도 수행 가능 하다는 것입니다.

하나의 코어로 여러 작업을 수행할 수 있는 이유는 문맥교환(context switch)의 개념 덕분입니다.

![문맥 교환 이미지](/assets/image/context_switch.png)

다음의 이미지를 보면 하나의 코어에 여러 작업이 할당되어 있습니다.

흰 선은 서브 시스템(모듈) 간의 문맥 교환(context switch)을 나타냅니다.

문맥 교환이 빠르게 일어나며 사용자는 여러 작업이 동시에 일어나는 것처럼 착각하게 됩니다.

> 하지만 큰 힘에는 큰 책임이 따르는 법입니다.

적은 수의 교환은 동시성 프로그래밍을 가능하게 해주므로 좋습니다.

하지만 수 천 번 이런 교환이 일어난다면 어떨까요 ?

![과도한 문맥 교환](/assets/image/context_switch_overhead.png)

문맥 교환에서 소요되는 비용은 시간 뿐만이 아니라 코어가 만든 문맥 기록도 해당됩니다.

문맥 교환을 수행할 때마다 이런 기록을 다시 얻어야 합니다. 이것은 **순수한 오버헤드** 입니다.

따라서 문맥 교환은 과도하게 해서 오히려 성능을 떨어뜨리는 상황이 발생하지 않도록 주의해야 합니다.

# 스레드 그리고 다중 스레드

스레드는 CPU 이용의 기본 단위입니다.

스레드는 같은 프로세스에 속한 다른 스레드와 자원을 공유합니다.

다중 스레드 프로그래밍의 개념이 나오고 프로그래머들은 스레드를 직접 생성하는 방식으로 동시성 코드를 작성했습니다.

하지만 이는 프로그래밍을 굉장히 어렵게 하고 스레드가 너무 많이 생성되는 상황으로 이어집니다.

스레드를 많이 만든다고 해서 성능이 무조건 좋아지는 것은 아닙니다.

![스루풋](/assets/image/throughput.png)

위의 그림과 같이 어느 시점에서 처리량은 더이상 늘어나지 않습니다. 그리고 앞서 설명한 것처럼 많은 스레드는 많은 문맥교환을 요구해 오버헤드를 증가시키게 됩니다.

# 라이브러리를 통한 스레드 관리

앞선 문제점으로 다중 스레드 프로그래밍의 전략은 달라졌습니다.

스레드 관리의 주도권이 시스템에게 넘어갔습니다. 그리고 프로그래머는 라이브러리를 통해 작업을 할당하기만 합니다.

## GCD

main 스레드와 백그라운드 스레드.

sync vs async, serial vs concurrent

## async/await

# 데이터 경쟁

# 참고
